# EECS 345 Final Cheat-Sheet

## Table of Contents
[Notes from Prof. Connamacher](#Notes-from-Connamacher)  
[Denotational Semantics](#Denotational-Semantics)  
[Scheme](#Scheme)  
[Haskell](#Haskell)  
[Prolog](#Prolog)  
[Homework Solutions](#Homework-Solutions)  

---

## Notes from Connamacher
- all at the same time
- typed into canvas
- write programs
    - scheme
    - haskell (won't be picky, but more so than Prolog)
        - will involve types
    - prolog (won't be picky, wont compile himself)
    - open book, open note -> can write the program and run, but shouldn't spend a lot of time if you choose to do so
    - he is mainly looking for thought process when we code (don't try and implements a Java construct in Haskell, etc)
- Closures
- Denotational Semantics
- everything that's shown up on a homework problem
- NO axiomatic semantics
- NO static semantics
- NO basic definitions

---

## Denotational Semantics

- mapping a syntax construct to a mathematical object
- **<code>M<sub>value</sub></code>**
    - m stands for "mapping"
    - maps the value of a symbol
    - ex: <code>M<sub>value</sub>('123') = Mv('1') * 100 + Mv('2') * 10 + Mv('3')</code>
    - used to convert from BNF rules to actual values
- **state**
    - a mathematical object which is a mapping between names a values
    - ex: <code>((x,5)(y,10),(z,0))</code>
        - can us a **LOOKUP** function to retrieve variable values
    - this should be conjoined with  Mv functions to conjoin BNF rules and variable values
    - therefore: <code>Mv(*variable*, state) = Mv(Lookup(*variable*, state))</code>
- Side Effects
    - can happen if a state changes in a conditional
    - ex: <code>if(i = 3 > 2)</code> would have an affect on the state of the program
    - to account for this make sure you replace <code>state</code> with <code>Ms(\<conditional\>, Ms(state))</code> where it is needed. Just be sure to think through these problems thoroughly.

---

## Scheme
### Prof. Connamacher's Scheme Lecture Files
#### Lecture #1
```Scheme
#lang racket
; This is a comment.
; This function counts the number of elements in a list
(define len
  (lambda (lis)
    ; (if condition then-function else-function)
    (if (null? lis)
        0
        (+ 1 (len (cdr lis))))))

; Determine if an atom is an element of a list of atoms
; Given an element x and a list lis
; case: the list is empty => #f
; case: list is not empty and the first element is x => #t
; case: list is not empty and the first element is not x => recurse
(define member?
  (lambda (x lis)
    (if (null? lis)
        #f
        (if (eq? x (car lis))
            #t
            (member? x (cdr lis))))))

; The same thing as member? but demonstrates the use of cond to replace nested if's
(define member2?
  (lambda (x lis)
    (cond
      [(null? lis)       #f]
      [(eq? x (car lis)) #t]
      [else              (member2? x (cdr lis))])))

; sumnumbers sums all the numbers in a list
(define sumnumbers
  (lambda (lis)
    (cond
      [(null? lis) 0]
      [(number? (car lis)) (+ (car lis) (sumnumbers (cdr lis)))]
      [else (sumnumbers (cdr lis))])))

; compute the factorial of a non-negative integer
(define factorial
  (lambda (x)
    (if (zero? x)
        1
        (* x (factorial (- x 1))))))

```
#### Lecture #2
```Scheme
#lang racket

; repeat takes an atom and a number and creates a list with that many copies of the atom
; (repeat 'x 6)  =>  '(x x x x x x)
(define repeat
  (lambda (a n)
    (if (zero? n)
        '()
        (cons a (repeat a (- n 1))))))

; myremove takes an atom and a list and returns the list (*) with the first copy of the atom removed
; (myremove 'x '(a b x c x d))    =>  '(a b c x d)
(define myremove
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) a) (cdr lis)]
      [else (cons (car lis) (myremove a (cdr lis)))])))

; myremoveall takes an atom and a list of atoms and removes all copies of the atom from the list
(define myremoveall
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) a) (myremoveall a (cdr lis))]
      [else (cons (car lis) (myremoveall a (cdr lis)))])))

; replaceall takes two atoms and a list and replaces every occurance of the first atom
;  with the second in the list
(define replaceall
  (lambda (old new lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) old) (cons new (replaceall old new (cdr lis)))]
      [else (cons (car lis) (replaceall old new (cdr lis)))])))

; squares takes a list of numbers and creates a list of the square of each number
(define squares
  (lambda (lis)
    (if (null? lis)
        '()
        (cons (* (car lis) (car lis)) (squares (cdr lis))))))

; myappend takes two lists and concatenates them:
;   (myappend '(a b c) '(d e))    =>   '(a b c d e)
(define myappend
  (lambda (l1 l2)
    (if (null? l1)
        l2
        (cons (car l1) (myappend (cdr l1) l2)))))

; myreverse takes a list and returns a list with the contents of the input list reversed
;   (myreverse '(a b c d e))    =>   '(e d c b a)
(define myreverse
  (lambda (lis)
    (if (null? lis)
        '()
        (myappend (myreverse (cdr lis)) (cons (car lis) '())))))

```
#### Lecture #3
```Scheme
#lang racket

; remove an every element from a list of atoms
(define removeall
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? a (car lis)) (removeall a (cdr lis))]
      [else (cons (car lis) (removeall a (cdr lis)))])))

; remove every element from a list that contains atoms and sublists, and lists of lists, etc.
(define removeall*
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (cons (removeall* a (car lis)) (removeall* a (cdr lis)))]
      [(eq? a (car lis)) (removeall* a (cdr lis))]
      [else (cons (car lis) (removeall* a (cdr lis)))])))

; is an element in a list of atoms?
;(define member?
;  (lambda (a lis)
;    (cond
;      [(null? lis) #f]
;      [(eq? a (car lis)) #t]
;      [else (member? a (cdr lis))])))

; is an element in a list of atoms?
(define member?
  (lambda (a lis)
    (if (null? lis)
        #f
        (or (eq? a (car lis)) (member? a (cdr lis))))))

; is a in a list that contains lists?
(define member*?
  (lambda (a lis)
    (cond
      [(null? lis) #f]
      [(list? (car lis)) (or (member*? a (car lis)) (member*? a (cdr lis)))]
      [(eq? a (car lis)) #t]
      [else (member*? a (cdr lis))])))

(define emptyall
  (lambda (lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (cons (emptyall (car lis)) (emptyall (cdr lis)))]
      [else (emptyall (cdr lis))])))

(define flatten
  (lambda (lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (append (flatten (car lis)) (flatten (cdr lis)))]
      [else (cons (car lis) (flatten (cdr lis)))])))
```

---

## Haskell
### Prof. Connamacher's Haskell Lecture Files
#### Lecture #1
```Haskell
{- this is a comment -}

{- factorial function, 3 ways, first "standard" -}
factorial n =
    if n == 0
        then
            1
        else
            n * factorial (n - 1)

{- factorial using "lambda" -}
factorial2 =
    \n -> 
        if n == 0
            then
                1
            else
                n * factorial2 (n - 1)

{- factorial using pattern matching -}
factorial3 0 = 1
factorial3 n = n * factorial3 (n - 1)

{- myappend 3 ways -}
myappend1 l1 l2 =
    if l1 == []
        then
            l2
        else
            {- (cons (car l1) (myappend (cdr l1) l2)) -}
            (head l1) : myappend1 (tail l1) l2

{- myappend using lambda notation -}
myappend2 :: Eq a => [a] -> [a] -> [a] 
myappend2 =
    \l1 l2 ->
        if l1 == []
            then
                l2
            else
                (head l1) : myappend2 (tail l1) l2

{- myappend using patterns -}
myappend3 [] l    = l
myappend3 (h:t) l = h : myappend3 t l

{- remove all of an element from a list -}
removeall a [] = []
removeall a (h:t) = 
    if h == a
        then
            removeall a t
        else
            h : (removeall a t)

removeall2 _ [] = []
removeall2 a (h:t)
    | a == h      = removeall2 a t
    | otherwise   = h : removeall2 a t

{- replaceall :
      replaceall 1 2 [1,2,3,1,2,3]     =>  [2,2,3,2,2,3] -}
replaceall _ _ [] = []
replaceall a b (h:t) 
    | a == h       = b : replaceall a b t
    | otherwise    = h : replaceall a b t

{- myreverse : 
       myreverse [1,2,3,4]     =>   [4,3,2,1]  -}
myreverse [] = []
myreverse (h:t)  =  myappend3 (myreverse t) [h]

myreverse2 [] = []
myreverse2 (h:t) = (myreverse2 t) ++ [h]

myreverse3 [] = []
myreverse3 (h:t) = ((++) . myreverse3) t [h]

{- merge :
       merge [1,3,5,6] [2,3,7,8]   =>  [1,2,3,3,5,6,7,8]  -}
```

### Lecture #2
```Haskell
{- haskell cps -}

{- factorial-cps -}
factorial_cps n return =
    if n == 0
        then
            return 1
        else
            factorial_cps (n - 1) (\v -> return (n * v))

{- append-cps -}
append_cps [] l return = return l
append_cps (h:t) l return = append_cps t l (\v -> return (h:v))
        
{- split-cps: takes a list and returns two lists, dividing the elements between them -}
split_cps [] return    = return [] []
split_cps (h:t) return = split_cps t (\v1 v2 -> return v2 (h:v1))

{- merge-cps -}
merge_cps [] l return = return l
merge_cps l [] return = return l
merge_cps (h1:t1) (h2:t2) return
    | h1 < h2     = merge_cps t1 (h2:t2) (\v -> return (h1:v))
    | otherwise   = merge_cps t2 (h1:t1) (\v -> return (h2:v))

{- mergesort -}
mergesort [] return = return []
mergesort [a] return = return [a]
mergesort l return  = split_cps l (\l1 l2 -> mergesort l1 
                 (\s1 -> mergesort l2 (\s2 -> merge_cps s1 s2 return)))

{- defining types in Haskell -}

{- create a "coordinate" type, a coordinate can be 2 doubles or 3 doubles,
    the type is called "Coordinate", "Coord3D" and "Coord2D" are separate constructors
    for creating instances of this type -}

data Coordinate = Coord3D Double Double Double | Coord2D Double Double deriving (Show)

{- distance returns the distance between two coordinates -}
distance (Coord2D a b) (Coord2D c d) = sqrt((a - c) * (a - c) + (b-d) * (b-d))
-- distance (Coord3D a b c) (Coord3D a b c) = fill in the rest
```

### Lecture #3
```Haskell
-- type is creating a type alias
type Scale = Double

doubleScale:: Scale -> Scale
doubleScale n = 2*n

{- creating a data type -}
data Coordinate t = Zero | Coord1 t | Coord2 t t | Coord3 t t t deriving (Show)

instance (Floating t, Eq t) => Eq (Coordinate t) where
      c1 == c2  = distance c1 c2 == 0

{- helper methods to access the different parts of a Coordinate -}
getx Zero                = 0
getx (Coord1 a)          = a
getx (Coord2 a b)        = a
getx (Coord3 a b c)      = a

gety Zero                = 0
gety (Coord1 a)          = 0
gety (Coord2 a b)        = b
gety (Coord3 a b c)      = b

getz Zero                = 0
getz (Coord1 a)          = 0
getz (Coord2 a b)        = 0
getz (Coord3 a b c)      = c

{- distance funtion: computes the distance between two points -}
diffsquared a b dim = ((dim a - dim b) * (dim a - dim b))
distance a b = sqrt((diffsquared a b getx) + (diffsquared a b gety) + (diffsquared a b getz))

{- distance function, again, but as an infix function -}
(##) a b = distance a b

{- I want a function that will sum two coordinates (pairwise sum each individual
   value) If you sum two coordinates with different constructors, 
   the result should be the wider of the two 
   
   (Coord1 2.0) -|- (Coord2 3.0 4.0)   =>   (Coord2 5.0 4.0) -}

(-|-) Zero Zero                     = Zero
(-|-) (Coord3 x y z) a              = Coord3 (x + getx a) (y + gety a) (z + getz a)
(-|-) a (Coord3 x y z)              = Coord3 (x + getx a) (y + gety a) (z + getz a)
(-|-) (Coord2 x y) a                = Coord2 (x + getx a) (y + gety a)
(-|-) a (Coord2 x y)                = Coord2 (x + getx a) (y + gety a)
(-|-) a b                           = Coord1 (getx a + getx b)
```

### Lecture #4
```Haskell
{- binary tree.  A binary tree is leaf, (empty), a node with 2 children -}
data BinaryTree t = Empty | Leaf t | InnerNode t (BinaryTree t) (BinaryTree t) deriving (Show, Eq)

{- inorder conversion of the tree to a list -}
inorder Empty             = []
inorder (Leaf a)          = [a]
inorder (InnerNode a l r) = (inorder l) ++ a : (inorder r)   

{- pre-order conversion of the tree to a list (node, then left child, then right child) -}
preorder Empty             = []
preorder (Leaf a)          = [a]
preorder (InnerNode a l r) = a : (preorder l) ++ (preorder r)

{- insert an element into the tree in order -}
insert e Empty             =  Leaf e
insert e (Leaf a)     
    | e < a                =  InnerNode a (Leaf e) Empty         
    | otherwise            =  InnerNode a Empty (Leaf e)
insert e (InnerNode a l r)
    | e < a                =  InnerNode a (insert e l) r
    | otherwise            =  InnerNode a l (insert e r)

{- applytotree takes a function (of 1 input) and applies the function to all values stored in the tree
   Ex:  apply a function to double the value of each element in the tree -}
applytotree f Empty      = Empty
applytotree f (Leaf a)   = Leaf (f a)
applytotree f (InnerNode a l r)  = InnerNode (f a) (applytotree f l) (applytotree f r)

{- foldinorder, foldpostorder :
    takes a binary function and a value, it applies the function to a node value with the second value, the result is passed to the next node in the tree.
    for fold, use the input value as the second operand of the function -}
{- ex: use + as a function with 0 as the value, this with the fold function will sum all the values in the tree -}

foldinorder f v Empty  = v
foldinorder f v (Leaf a) = f a v
foldinorder f v (InnerNode a l r) = foldinorder f (f a (foldinorder f v l)) r

{- we can define inorder very simply:
    inorder t = foldpostorder (:) [] t
    -}
```

### Lecture #5
```Haskell
{- Monads are a type where a value is wrapped in a "context" to 
   give information about the value.  Examples are "promises" in web coding,
   Java's Optional -}
data RedBlack t = Red t | Black t

{- our "monad" example, a value -}
data Value t = Value t | NoValue deriving (Show)

{- We need two basic functions, return and bind -}

myreturn:: t -> Value t
myreturn x = Value x

mybind:: Value t -> (t -> Value s) -> Value s 
mybind (Value x) f = f x
mybind NoValue _   = NoValue

{- Let's create some math operations on the monad -}
(+++) vx vy = mybind vx (\x -> mybind vy (\y -> myreturn (x + y))) 
(~~)  vx vy = vx `mybind` (\x -> vy `mybind` (\y -> myreturn (x - y)))
(//)  vx vy = vx `mybind` (\x -> vy `mybind` (\y -> if y == 0 then NoValue else myreturn (x / y)))


{- Haskell has monads: Maybe, IO, list 

   data Maybe t = Just t | Nothing
   
   return function is return
   the bind function is >>= 
-}

(++++) mx my = mx >>= (\x -> my >>= (\y -> return (x + y))) 
(~~~) mx my = do
    x <- mx
    y <- my
    return (x - y)
{- division (///) and square root (msqrt) using the Maybe monad -}
msqrt mx = mx >>= (\x -> if x < 0 then Nothing else return (sqrt x))

(///) mx my = do
    x <- mx
    y <- my
    if y == 0 then Nothing else return (x / y)

{- mapply takes two monads mx my and a function f, I want to apply "mx `f` my" -}
myapply mx f my = do
    x <- mx
    y <- my
    return (f x y)
```

---

## Prolog
### Prof. Connamacher's Prolog Lecture Files
#### Lecture #1 (family)
```Prolog
% This is a comment
% A file is basically a database.
% Facts end in a period.
% values and predicates are all lowercase

parentof(arthur, ron).
parentof(molly, ron).
parentof(arthur, fred).
parentof(molly, fred).
parentof(arthur, george).
parentof(molly, george).
parentof(arthur, ginny).
parentof(molly, ginny).
parentof(james, harry).
parentof(lily, harry).
parentof(petunia, dudley).
parentof(vernon, dudley).
parentof(harry, albusjr).
parentof(ginny, albusjr).
parentof(harry, jamesjr).
parentof(ginny, jamesjr).
parentof(harry, lilyjr).
parentof(ginny, lilyjr).
parentof(mathilda, lily).
parentof(mathilda, petunia).
parentof(ron, rose).
parentof(hermione, rose).
parentof(ron, hugo).
parentof(hermione, hugo).

married(harry, ginny).
married(hermione, ron).
married(lily, james).

% Inference rules are the form:
%  A :- B, C.
% means, logically, that B and C implies A.
% all variables are upper case
grandparentof(A, B) :- parentof(A, X), parentof(X, B).

% sibling
sibling(A, B) :- parentof(X, A), parentof(X, B), A \= B.

% cousin (each of your parents are siblings)
cousin(A, B) :- parentof(X, A), parentof(Y, B), sibling(X, Y).

% parentinlaw (harry's inlaws are ginny's parents)
% a logical or is formed by multiple inference rules
parentinlaw(A,B) :- parentof(A,X), married(X,B).
parentinlaw(A,B) :- parentof(A,X), married(B,X).
```

#### Lecture #2 (lists)
```Prolog
% A list is [H | T] where H is the head (car) and T is the tail (cdr)
% mappend(operand1, operand2, result).
myappend([], L, L).
myappend([H|T], L, [H|S]) :- myappend(T, L, S).

% contains: is A an element of list L?
contains(A, [A|_]).
contains(A, [_|T]) :- contains(A,T).

% removeall, removes all occurrence of an element from a list
% myreverse, reverses a list
% myflatten, takes a list that contains sublists, and returns an list of just the elements
% removeallstar, takes an element and a list containing lists and removes all occurrences of the element

removeall(_, [], []).
removeall(X, [X|T], S) :- removeall(X, T, S).
removeall(X, [H|T], [H|S]) :- removeall(X, T, S).

myreverse([], []).
myreverse([H|T], R) :- myreverse(T, S), myappend(S, [H], R).

myflatten([], []).
% do the case where the head of the list is a list
myflatten([H|T], R) :- myflatten(H, FH), myflatten(T, FT), myappend(FH, FT, R).
% do the case where the head of the list is not a list
myflatten([H|T], [H|FT]) :- myflatten(T, FT). 

% For calculating numbers, we use "is"
% Everything to the right of the is must be fully resolved.
factorial(0,1).
factorial(N,F) :- M is N-1, factorial(M,R), F is R * N.
```

#### Lecture #3 (cut)
```Prolog
% factorial
% factorial(0,1).
% factorial(N, F) :- M is N - 1, factorial(M, R), !, F is R * N.

factorial(0,1).
factorial(N, F) :- factorial2(M, R), N is M + 1, F is R * N, !.

factorial2(0, 1).
factorial2(N, F) :- factorial2(M, R), N is M + 1, F is R * N.

% Prolog cut:  !
% This is a predicate that is always true.
% When crossing the cut, prolog fixes any resolved values to
% have only those values (no backtracking to try a new value)
% 
% After crossing the cut, only variables without values yet will we be still searching on

removeall(_, [], []).
removeall(A, [A|T], R) :- !, removeall(A, T, R).
removeall(A, [H|T], [H|R]) :- removeall(A, T, R).

contains(A, [A|_]) :- !.
contains(A, [_|T]) :- contains(A, T).

% Why are prolog rules only using a single value on the left side?
% (a :- b,c,d  ==   (b AND c AND d -> a)  ==
%   NOT(b and c and d) OR a)
%   (NOT b) OR (NOT c) OR (NOT d) OR A
% Clauses with a single true literal are "Horn" clauses,
%   and these can be resolved with a polynomial time algorithm
%
% The fastest known algorithms for resolving clauses with multiple positive literals are exponential time.
```

---

## Homework Solutions
(Links to Canvas)  
[Programming #1](https://canvas.case.edu/courses/20452/files/2268084?module_item_id=783952)  
~~[Programming #2]()~~  
~~[Written #1]()~~  
~~[Written #2]()~~  


---
[Back to TOC](#Table-of-Contents)