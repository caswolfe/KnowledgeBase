# EECS 345 Final Cheat-Sheet

## Table of Contents
[Notes from Prof. Connamacher](#Notes-from-Connamacher)  
[Denotational Semantics](#Denotational-Semantics)  
[Scheme](#Scheme)  
[Haskell](#Haskell)  
[Prolog](#Prolog)  
[Homework Solutions](#Homework-Solutions)  

---

## Notes from Connamacher
- all at the same time
- typed into canvas
- write programs
    - scheme
    - haskell (won't be picky, but more so than Prolog)
        - will involve types
    - prolog (won't be picky, wont compile himself)
    - open book, open note -> can write the program and run, but shouldn't spend a lot of time if you choose to do so
    - he is mainly looking for thought process when we code (don't try and implements a Java construct in Haskell, etc)
- Closures
- Denotational Semantics
- everything that's shown up on a homework problem
- NO axiomatic semantics
- NO static semantics
- NO basic definitions

---

## Denotational Semantics

- mapping a syntax construct to a mathematical object
- **<code>M<sub>value</sub></code>**
    - m stands for "mapping"
    - maps the value of a symbol
    - ex: <code>M<sub>value</sub>('123') = Mv('1') * 100 + Mv('2') * 10 + Mv('3')</code>
    - used to convert from BNF rules to actual values
- **state**
    - a mathematical object which is a mapping between names a values
    - ex: <code>((x,5)(y,10),(z,0))</code>
        - can us a **LOOKUP** function to retrieve variable values
    - this should be conjoined with  Mv functions to conjoin BNF rules and variable values
    - therefore: <code>Mv(*variable*, state) = Mv(Lookup(*variable*, state))</code>
- Side Effects
    - can happen if a state changes in a conditional
    - ex: <code>if(i = 3 > 2)</code> would have an affect on the state of the program
    - to account for this make sure you replace <code>state</code> with <code>Ms(\<conditional\>, Ms(state))</code> where it is needed. Just be sure to think through these problems thoroughly.

---

## Scheme
### Prof. Connamacher's Scheme Lecture Files
#### Lecture #1
```Scheme
#lang racket
; This is a comment.
; This function counts the number of elements in a list
(define len
  (lambda (lis)
    ; (if condition then-function else-function)
    (if (null? lis)
        0
        (+ 1 (len (cdr lis))))))

; Determine if an atom is an element of a list of atoms
; Given an element x and a list lis
; case: the list is empty => #f
; case: list is not empty and the first element is x => #t
; case: list is not empty and the first element is not x => recurse
(define member?
  (lambda (x lis)
    (if (null? lis)
        #f
        (if (eq? x (car lis))
            #t
            (member? x (cdr lis))))))

; The same thing as member? but demonstrates the use of cond to replace nested if's
(define member2?
  (lambda (x lis)
    (cond
      [(null? lis)       #f]
      [(eq? x (car lis)) #t]
      [else              (member2? x (cdr lis))])))

; sumnumbers sums all the numbers in a list
(define sumnumbers
  (lambda (lis)
    (cond
      [(null? lis) 0]
      [(number? (car lis)) (+ (car lis) (sumnumbers (cdr lis)))]
      [else (sumnumbers (cdr lis))])))

; compute the factorial of a non-negative integer
(define factorial
  (lambda (x)
    (if (zero? x)
        1
        (* x (factorial (- x 1))))))

```
#### Lecture #2
```Scheme
#lang racket

; repeat takes an atom and a number and creates a list with that many copies of the atom
; (repeat 'x 6)  =>  '(x x x x x x)
(define repeat
  (lambda (a n)
    (if (zero? n)
        '()
        (cons a (repeat a (- n 1))))))

; myremove takes an atom and a list and returns the list (*) with the first copy of the atom removed
; (myremove 'x '(a b x c x d))    =>  '(a b c x d)
(define myremove
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) a) (cdr lis)]
      [else (cons (car lis) (myremove a (cdr lis)))])))

; myremoveall takes an atom and a list of atoms and removes all copies of the atom from the list
(define myremoveall
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) a) (myremoveall a (cdr lis))]
      [else (cons (car lis) (myremoveall a (cdr lis)))])))

; replaceall takes two atoms and a list and replaces every occurance of the first atom
;  with the second in the list
(define replaceall
  (lambda (old new lis)
    (cond
      [(null? lis) '()]
      [(eq? (car lis) old) (cons new (replaceall old new (cdr lis)))]
      [else (cons (car lis) (replaceall old new (cdr lis)))])))

; squares takes a list of numbers and creates a list of the square of each number
(define squares
  (lambda (lis)
    (if (null? lis)
        '()
        (cons (* (car lis) (car lis)) (squares (cdr lis))))))

; myappend takes two lists and concatenates them:
;   (myappend '(a b c) '(d e))    =>   '(a b c d e)
(define myappend
  (lambda (l1 l2)
    (if (null? l1)
        l2
        (cons (car l1) (myappend (cdr l1) l2)))))

; myreverse takes a list and returns a list with the contents of the input list reversed
;   (myreverse '(a b c d e))    =>   '(e d c b a)
(define myreverse
  (lambda (lis)
    (if (null? lis)
        '()
        (myappend (myreverse (cdr lis)) (cons (car lis) '())))))

```
#### Lecture #3
```Scheme
#lang racket

; remove an every element from a list of atoms
(define removeall
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(eq? a (car lis)) (removeall a (cdr lis))]
      [else (cons (car lis) (removeall a (cdr lis)))])))

; remove every element from a list that contains atoms and sublists, and lists of lists, etc.
(define removeall*
  (lambda (a lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (cons (removeall* a (car lis)) (removeall* a (cdr lis)))]
      [(eq? a (car lis)) (removeall* a (cdr lis))]
      [else (cons (car lis) (removeall* a (cdr lis)))])))

; is an element in a list of atoms?
;(define member?
;  (lambda (a lis)
;    (cond
;      [(null? lis) #f]
;      [(eq? a (car lis)) #t]
;      [else (member? a (cdr lis))])))

; is an element in a list of atoms?
(define member?
  (lambda (a lis)
    (if (null? lis)
        #f
        (or (eq? a (car lis)) (member? a (cdr lis))))))

; is a in a list that contains lists?
(define member*?
  (lambda (a lis)
    (cond
      [(null? lis) #f]
      [(list? (car lis)) (or (member*? a (car lis)) (member*? a (cdr lis)))]
      [(eq? a (car lis)) #t]
      [else (member*? a (cdr lis))])))

(define emptyall
  (lambda (lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (cons (emptyall (car lis)) (emptyall (cdr lis)))]
      [else (emptyall (cdr lis))])))

(define flatten
  (lambda (lis)
    (cond
      [(null? lis) '()]
      [(list? (car lis)) (append (flatten (car lis)) (flatten (cdr lis)))]
      [else (cons (car lis) (flatten (cdr lis)))])))
```

---

## Haskell
### Prof. Connamacher's Scheme Lecture Files
#### Lecture #1
```Haskell
{- this is a comment -}

{- factorial function, 3 ways, first "standard" -}
factorial n =
    if n == 0
        then
            1
        else
            n * factorial (n - 1)

{- factorial using "lambda" -}
factorial2 =
    \n -> 
        if n == 0
            then
                1
            else
                n * factorial2 (n - 1)

{- factorial using pattern matching -}
factorial3 0 = 1
factorial3 n = n * factorial3 (n - 1)

{- myappend 3 ways -}
myappend1 l1 l2 =
    if l1 == []
        then
            l2
        else
            {- (cons (car l1) (myappend (cdr l1) l2)) -}
            (head l1) : myappend1 (tail l1) l2

{- myappend using lambda notation -}
myappend2 :: Eq a => [a] -> [a] -> [a] 
myappend2 =
    \l1 l2 ->
        if l1 == []
            then
                l2
            else
                (head l1) : myappend2 (tail l1) l2

{- myappend using patterns -}
myappend3 [] l    = l
myappend3 (h:t) l = h : myappend3 t l

{- remove all of an element from a list -}
removeall a [] = []
removeall a (h:t) = 
    if h == a
        then
            removeall a t
        else
            h : (removeall a t)

removeall2 _ [] = []
removeall2 a (h:t)
    | a == h      = removeall2 a t
    | otherwise   = h : removeall2 a t

{- replaceall :
      replaceall 1 2 [1,2,3,1,2,3]     =>  [2,2,3,2,2,3] -}
replaceall _ _ [] = []
replaceall a b (h:t) 
    | a == h       = b : replaceall a b t
    | otherwise    = h : replaceall a b t

{- myreverse : 
       myreverse [1,2,3,4]     =>   [4,3,2,1]  -}
myreverse [] = []
myreverse (h:t)  =  myappend3 (myreverse t) [h]

myreverse2 [] = []
myreverse2 (h:t) = (myreverse2 t) ++ [h]

myreverse3 [] = []
myreverse3 (h:t) = ((++) . myreverse3) t [h]

{- merge :
       merge [1,3,5,6] [2,3,7,8]   =>  [1,2,3,3,5,6,7,8]  -}
```

### Lecture #2
```Haskell
{- haskell cps -}

{- factorial-cps -}
factorial_cps n return =
    if n == 0
        then
            return 1
        else
            factorial_cps (n - 1) (\v -> return (n * v))

{- append-cps -}
append_cps [] l return = return l
append_cps (h:t) l return = append_cps t l (\v -> return (h:v))
        
{- split-cps: takes a list and returns two lists, dividing the elements between them -}
split_cps [] return    = return [] []
split_cps (h:t) return = split_cps t (\v1 v2 -> return v2 (h:v1))

{- merge-cps -}
merge_cps [] l return = return l
merge_cps l [] return = return l
merge_cps (h1:t1) (h2:t2) return
    | h1 < h2     = merge_cps t1 (h2:t2) (\v -> return (h1:v))
    | otherwise   = merge_cps t2 (h1:t1) (\v -> return (h2:v))

{- mergesort -}
mergesort [] return = return []
mergesort [a] return = return [a]
mergesort l return  = split_cps l (\l1 l2 -> mergesort l1 
                 (\s1 -> mergesort l2 (\s2 -> merge_cps s1 s2 return)))

{- defining types in Haskell -}

{- create a "coordinate" type, a coordinate can be 2 doubles or 3 doubles,
    the type is called "Coordinate", "Coord3D" and "Coord2D" are separate constructors
    for creating instances of this type -}

data Coordinate = Coord3D Double Double Double | Coord2D Double Double deriving (Show)

{- distance returns the distance between two coordinates -}
distance (Coord2D a b) (Coord2D c d) = sqrt((a - c) * (a - c) + (b-d) * (b-d))
-- distance (Coord3D a b c) (Coord3D a b c) = fill in the rest
```

### Lecture #3
```Haskell
-- type is creating a type alias
type Scale = Double

doubleScale:: Scale -> Scale
doubleScale n = 2*n

{- creating a data type -}
data Coordinate t = Zero | Coord1 t | Coord2 t t | Coord3 t t t deriving (Show)

instance (Floating t, Eq t) => Eq (Coordinate t) where
      c1 == c2  = distance c1 c2 == 0

{- helper methods to access the different parts of a Coordinate -}
getx Zero                = 0
getx (Coord1 a)          = a
getx (Coord2 a b)        = a
getx (Coord3 a b c)      = a

gety Zero                = 0
gety (Coord1 a)          = 0
gety (Coord2 a b)        = b
gety (Coord3 a b c)      = b

getz Zero                = 0
getz (Coord1 a)          = 0
getz (Coord2 a b)        = 0
getz (Coord3 a b c)      = c

{- distance funtion: computes the distance between two points -}
diffsquared a b dim = ((dim a - dim b) * (dim a - dim b))
distance a b = sqrt((diffsquared a b getx) + (diffsquared a b gety) + (diffsquared a b getz))

{- distance function, again, but as an infix function -}
(##) a b = distance a b

{- I want a function that will sum two coordinates (pairwise sum each individual
   value) If you sum two coordinates with different constructors, 
   the result should be the wider of the two 
   
   (Coord1 2.0) -|- (Coord2 3.0 4.0)   =>   (Coord2 5.0 4.0) -}

(-|-) Zero Zero                     = Zero
(-|-) (Coord3 x y z) a              = Coord3 (x + getx a) (y + gety a) (z + getz a)
(-|-) a (Coord3 x y z)              = Coord3 (x + getx a) (y + gety a) (z + getz a)
(-|-) (Coord2 x y) a                = Coord2 (x + getx a) (y + gety a)
(-|-) a (Coord2 x y)                = Coord2 (x + getx a) (y + gety a)
(-|-) a b                           = Coord1 (getx a + getx b)
```

### Lecture #4
```Haskell
{- binary tree.  A binary tree is leaf, (empty), a node with 2 children -}
data BinaryTree t = Empty | Leaf t | InnerNode t (BinaryTree t) (BinaryTree t) deriving (Show, Eq)

{- inorder conversion of the tree to a list -}
inorder Empty             = []
inorder (Leaf a)          = [a]
inorder (InnerNode a l r) = (inorder l) ++ a : (inorder r)   

{- pre-order conversion of the tree to a list (node, then left child, then right child) -}
preorder Empty             = []
preorder (Leaf a)          = [a]
preorder (InnerNode a l r) = a : (preorder l) ++ (preorder r)

{- insert an element into the tree in order -}
insert e Empty             =  Leaf e
insert e (Leaf a)     
    | e < a                =  InnerNode a (Leaf e) Empty         
    | otherwise            =  InnerNode a Empty (Leaf e)
insert e (InnerNode a l r)
    | e < a                =  InnerNode a (insert e l) r
    | otherwise            =  InnerNode a l (insert e r)

{- applytotree takes a function (of 1 input) and applies the function to all values stored in the tree
   Ex:  apply a function to double the value of each element in the tree -}
applytotree f Empty      = Empty
applytotree f (Leaf a)   = Leaf (f a)
applytotree f (InnerNode a l r)  = InnerNode (f a) (applytotree f l) (applytotree f r)

{- foldinorder, foldpostorder :
    takes a binary function and a value, it applies the function to a node value with the second value, the result is passed to the next node in the tree.
    for fold, use the input value as the second operand of the function -}
{- ex: use + as a function with 0 as the value, this with the fold function will sum all the values in the tree -}

foldinorder f v Empty  = v
foldinorder f v (Leaf a) = f a v
foldinorder f v (InnerNode a l r) = foldinorder f (f a (foldinorder f v l)) r

{- we can define inorder very simply:
    inorder t = foldpostorder (:) [] t
    -}
```

### Lecture #5
```Haskell
{- Monads are a type where a value is wrapped in a "context" to 
   give information about the value.  Examples are "promises" in web coding,
   Java's Optional -}
data RedBlack t = Red t | Black t

{- our "monad" example, a value -}
data Value t = Value t | NoValue deriving (Show)

{- We need two basic functions, return and bind -}

myreturn:: t -> Value t
myreturn x = Value x

mybind:: Value t -> (t -> Value s) -> Value s 
mybind (Value x) f = f x
mybind NoValue _   = NoValue

{- Let's create some math operations on the monad -}
(+++) vx vy = mybind vx (\x -> mybind vy (\y -> myreturn (x + y))) 
(~~)  vx vy = vx `mybind` (\x -> vy `mybind` (\y -> myreturn (x - y)))
(//)  vx vy = vx `mybind` (\x -> vy `mybind` (\y -> if y == 0 then NoValue else myreturn (x / y)))


{- Haskell has monads: Maybe, IO, list 

   data Maybe t = Just t | Nothing
   
   return function is return
   the bind function is >>= 
-}

(++++) mx my = mx >>= (\x -> my >>= (\y -> return (x + y))) 
(~~~) mx my = do
    x <- mx
    y <- my
    return (x - y)
{- division (///) and square root (msqrt) using the Maybe monad -}
msqrt mx = mx >>= (\x -> if x < 0 then Nothing else return (sqrt x))

(///) mx my = do
    x <- mx
    y <- my
    if y == 0 then Nothing else return (x / y)

{- mapply takes two monads mx my and a function f, I want to apply "mx `f` my" -}
myapply mx f my = do
    x <- mx
    y <- my
    return (f x y)
```

---

## Prolog
### Prof. Connamacher's Scheme Lecture Files
#### Lecture #1

---

## Homework Solutions
(Links to Canvas)  
[Programming #1](https://canvas.case.edu/courses/20452/files/2268084?module_item_id=783952)  
~~[Programming #2]()~~  
~~[Written #1]()~~  
~~[Written #2]()~~  


---
[Back to TOC](#Table-of-Contents)