# L06 - January 27th, 2020

- more syntax, last one to overlap w/ compilers

# static semantics
- expressing syntax rules that we can't enforce w/ the BNF production rules
	- ex:
		- all variables declared b/f use
		- all function calls have the correct # of parameters
		- make sure that all expressions have correct types
- given a parse tree, **decorate** the tree w/ attributes
	- ex:
		- <code>(s)->(deceleration)(statement)</code>
			- decl = decelerations
		- <code>(s)->(type)(var)</code>
		- <code>(s)->(assign)(s)</code>
		- <code>(assign)->(var) = (value)</code>
		- <code>(value)->(value)+(b)| (b)</code>
		- <code>(b)->(b)*(c)|(c)</code>
		- <code>(c)->(number)|(var)</code>
- suppose you want to parse:
	- <code>int z;</code>
	- <code>double x;</code>  
	- <code>x = 30 + 5 * z;</code>
- type attribute
	- give the type of any expression
	- attached to a node on the parse tree
	- value of the type moves upward
	- type is a **synthesized** attribute, it is determined by the types of the children
- type table
	- attribute that stores the types of declared variables in the program
	- an **inherited** attribute
	- value of the attribute f/ a node is determined by its parent and its left siblings
	- this allows types for declared variables to be propagated to where that variable is used
- all attributes must be either **synthetic** or **inherited**, never both
- rules for type table
	- to differentiate, we add subscripts to the parse tree rules
	- NOTE THAT THESE SUBSCRIPTS ARE ONLY USED FOR THE TABLE, NEVER USED IN CREATING THE TREE
	- ex:
		- <code>(s<sub>1</sub>)->(decl)(s<sub>2</sub>)</code>
		- <code>s2.typetable := s<sub>1</sub>.typetable Union decl.typetable</code>
	- another ex:
		- <code>(s<sub>1</sub>)->(assign)(s<sub>2</sub>)</code>
		- <code>s<sub>2</sub>.typetable := s<sub>1</sub>.typetable</code>
	- others
		- <code>decl.typetable = s<sub>1</sub>.typetable</code>
	- must create a synthesized attribute to propagate attributes upward
		- typebinding
			- <code>decl.typebinding := ((var).name, (type).type)</code>
- order is to move things up, then move things down
- Prof. sugests to look at the textbook (scoot)
- @ the assign node is where type checking will actually happen
	- test that <code>var.type = double OR value.type = int</code>