# L05 - January 24th, 2020

- "They got hard very very quick..." - some dude sitting up front of the class
- recursive pattern for all of the homework, don't be a dumb dumb
- overlap w/ compilers!

# syntax & semantics
- syntax
	- the form of an instruction
- semantics
	- what the instruction means
- ex:
	- <code>x = 5;</code>
	- syntax:
		- <identifier> = <value>;
		- <code><></code> mean that it isn't in the language itself but it represents something which is
		- since the <code>=</code> isn't in brackets that means its apart of the actual language
	- semantics:
		- stores <code>5</code> in a memory address referred to with the name x
- today will be syntax, the rest of the course will be semantics

# Syntax
- syntax is written in "Backus-Naur Form" (BNF)
- A list of production rules:
	- <code><assign> -> <identifier> = <value></code>
	- <code><></code> is a non-terminal
	- <code>=</code> is a **terminal**
- production rules:
	- <code><program> -> begin <statement list> end</code>
	- production rule
		- <code><statement list> -> <statement>; <statement list></code>
		- <code><statement list> -> <statement?;</code>
		- <code><statement> -> <variable declaration></code>
		- <code><statement> -> <assignment></code>
		- <code><statement> -> <if statement></code>
		- <code><statement> -> <return></code>
		- <code><return> -> return <value></code>
		- <code><assignment> -> <identifier> = <value></code>
		- <code><variable declaration> -> <type> <value></code>
		- <code><value> -> <value> * <value></code>
		- <code><value> -> <identifier></code>
		- <code><value> -> 0</code>
	- this is a "context free" definition
		- b/c only a single non-terminal on the left side
	- program ex:
		- <code>begin <statement list> end</code>
		- <code>begin <statement>; <statement list> end</code>
		- <code>begin <variable declaration>; <statement list> end</code>
		- <code>begin <variable declaration>; <statement>; <statement list> end</code>
		- <code>begin <variable declaration>; <assign>; <statement> end</code>
		- <code>begin <type> <identifier>; <identifier> <value>; <return> end</code>
		- more stuff
		- <code>begin int x; x = 5; return x end</code>
- can also use this language to parse
- <code>a * b + c</code>
	- rules
		- <code>[s] -> [s] * [s]</code>
		- <code>[s] -> [s] + [s]</code>
		- <code>[s] -> a</code>
		- <code>[s] -> b</code>
		- <code>[s] -> c</code>
	1) <code>[s] * [s] + [s]</code>
		- <code>[s] -> [s] + [s]</code>
	1) <code>[s] * [s]</code>
		- <code>[s] -> [s] * [s]</code>
	1) <code>[s]</code>
	- it is a valid statement
- can work backwards!
	- <code>[s]</code>
	- <code>[s] * [s]</code>
	- <code>c * [s] * [s]</code>
	- and so on
- precedence & associativity 
	- currently can parse / construct in many ways, need rules to prevent this
		- also known as "ambiguous grammar"
			- can make 2 different parse trees from the same sentence
			- this ain't it coach
	- to create precedence create a new non-terminal and move the higher precedent operation "down" the production rules
	- ex:
		- <code>[s] -> [s] + [s] | [a]</code>
		- <code>[a] -> [a] * [a]</code>
		- <code>[a] -> a | b | c</code>
		- parsing ex:
			- <code>a * b + c</code>
				- <code>[a] -> a | b | c</code>
			- <code>[a] * [a] + [a]</code>
				- <code>[a] -> [a] * [a]</code>
			- <code>[a] + [a]</code>
				- <code>[s] -> [s] + [s] | [a]</code>
			- <code>[s] + [s]</code>
				- <code>[s] -> [s] + [s] | [a]</code>
			- <code>[s]</code>
		- run it back
			- <code>a * b + c</code>
			- <code>[a] * [a] + [a]</code>
			- <code>[s] * [s] + [s]</code>
			- <code>[s] * [s]</code>
			- invalid, no rule that can apply and thus precedence has been created
	- current rules are still ambiguous, still need to complete it...
	- associativity
		- left to right or right to left
		- <code>[s] -> [s] op [a] | [a]</code>
		- <code>a op b op c</code>
		- <code>[a] op [a] op [a]</code>
		- <code>[s] op [a] op [a]</code>
		- <code>[s] op [a]</code>
		- <code>[s]</code>
		- this rule is left associative
			- (new non-terminal goes on the right)
	- addition and multiplication are both left associative
	- unambiguous rule set:
		- <code>[s] -> [s] + [a] | [a]</code>
		- <code>[a] -> [a] * [b] | [b]</code>
		- <code>[b] -> a | b | c</code>
			- notes
				- <code>[b] -> a | b | c | [s]</code>
					- **CREATES AMBIGIOUTY**
				- <code>[b] -> a | b | c | ([s])</code>
					- no longer ambiguous