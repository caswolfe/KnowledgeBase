# L08 - January 31st 2020

- now we are doing the "real class material"

# denotational semantics
- map a syntax construct to a mathematical object
- ex: Integers
	- Digit, Leading Digit, and Sequence of Numbers
	- <code>(D)-> 0 | (LD)</code>
	- <code>(LD)-> 1 | 2 | 3 | ... | 9</code>
	- <code>(N)-> (D) | (LD)(SN)</code>
	- <code>(SN<sub>1</sub>)-> (SN<sub>2</sub>)(D)|(D)</code>
	- M stands f/ "Mapping"
	- <code>M<sub>value</sub>('2')->2</code>
		- this is a function which goes from our BNF rule to two
	- <code>M<sub>value</sub>((SN<sub>1</sub>)) = M<sub>value</sub>((SN<sub>2</sub>)(D))</code>
		- <code> = M<sub>value</sub>((D)) * 10 + M<sub>value</sub>((SN<sub>2</sub>))</code>
	- ex: <code>M<sub>value</sub>315</code>
		- <code> = Mv(3) * 10 + Mv(15)</code>
		- <code> = ((Mv(3) * 10 + Mv(1)) * 10 + Mv(5))</code>
		- <code> = 315</code>
	- <code>Mv((A)'+'(B))</code>
		- <code>Mv(A) + Mv(B)</code>
		- <code>for Java, it is</code>
			- <code>(2<sup>31</sup> + (Mv(A) + Mv(B))) mod (2<sup>32</sup> - 2<sup>31</sup>)</code>
- what about <code>x = x + 1?</code>
	- BNF:
		- <code>(assign) -> (variable) = (value)</code>
		- <code>Mv((assign))</code>
			- <code>Mv((var) = (value))</code>
	- **State**
		- a mathematical object that is a mapping between names and values
		- ex: var names & the values stored
		- can use a "set of pairs" to represent the state
		- ex: ((x,5)(y,10)(z,0))
	- revisit <code>sMv((A)+(B))</code>
		- <code>Mv((A)) + Mv((B))</code>
		- need to modify Mv definition
		- <code>Mv: BNF cross state</code>
		- <code>Mv((var), state) = Lookup(Mname((variable), state)</code>
		- <code>Mname: BNF -> string</code>
		- modify Mv to return "int union {error}"
			- the error is for **SYNTAX ERRORS ONLY**
				- **THIS WILL BE ON A MOTHER FUCKING GOD DAMN TEST DUMB ASS**
		- <code>Mv((var)) = (value) ,state = Mv((value), state)</code>
		- <code>M<sub>state</sub>: BNF to state -> sttate + {error}</code>
			- <code>Ms((var) = (value), state) = </code>
				- if lookup(Mv((var)), state) = error then error
				- else state2 = remove(Mn((var), state)
					- state3 = add(Mn((var)), Mv((val)), state) state2
				- state3 (*we returning state 3*)